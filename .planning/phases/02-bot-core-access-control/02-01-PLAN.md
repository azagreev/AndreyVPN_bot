---
phase: 02-bot-core-access-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/handlers/onboarding.py
  - bot/handlers/admin.py
  - bot/handlers/__init__.py
  - bot/middlewares/access_middleware.py
  - main.py
  - scripts/verify_phase2.py
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-03]
must_haves:
  truths:
    - "Новые пользователи получают математическую капчу при команде /start"
    - "Администратор получает уведомление с кнопками одобрения/отклонения"
    - "Middleware блокирует доступ к функциям бота для неодобренных пользователей"
  artifacts:
    - path: "bot/handlers/onboarding.py"
      provides: "Обработка команды /start и капчи"
    - path: "bot/handlers/admin.py"
      provides: "Обработка действий администратора"
    - path: "bot/middlewares/access_middleware.py"
      provides: "Фильтрация доступа по статусу is_approved"
  key_links:
    - from: "bot/handlers/onboarding.py"
      to: "bot/handlers/admin.py"
      via: "уведомление администратора"
    - from: "bot/middlewares/access_middleware.py"
      to: "database"
      via: "проверка поля is_approved"
---

<objective>
Реализовать ядро бота с системой контроля доступа: математическая капча при первом входе, процесс одобрения администратором и middleware для ограничения доступа.

Цель: Обеспечить безопасность бота, разрешая доступ только проверенным пользователям после ручного подтверждения администратором.
Выход: Работающая система регистрации, уведомлений админа и фильтрации команд.
</objective>

<execution_context>
@/home/azagreev/.gemini/get-shit-done/workflows/execute-plan.md
@/home/azagreev/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-bot-core-access-control/RESEARCH.md
@bot/db/models.py
@bot/core/config.py
</context>

<tasks>

<task type="auto">
  <name>Задание 1: Реализация капчи и регистрации (AUTH-01)</name>
  <files>
    - bot/handlers/onboarding.py
    - bot/handlers/__init__.py
  </files>
  <action>
    1. Создать `bot/handlers/onboarding.py`.
    2. Реализовать `CaptchaStates` с использованием `StatesGroup`.
    3. Добавить хендлер на `/start`:
       - Если пользователь уже одобрен (проверка в БД), показать главное меню (заглушка).
       - Если нет, сгенерировать случайный пример (сложение 1-20), сохранить ответ в FSM и отправить пользователю на русском.
    4. Добавить хендлер для ответа на капчу:
       - Если верно: создать запись в `users` (is_approved=0) и `approvals` (status='pending'), уведомить пользователя об ожидании.
       - Если неверно: попросить повторить или сгенерировать новый пример.
    5. Зарегистрировать роутер в `bot/handlers/__init__.py`.
  </action>
  <verify>
    <automated>pytest (если настроен) или ручная проверка через бота</automated>
    <manual>Отправить /start боту, получить пример, ответить верно/неверно, проверить запись в БД sqlite3 bot_data.db "SELECT * FROM users;"</manual>
    <sampling_rate>после выполнения задания</sampling_rate>
  </verify>
  <done>Пользователь получает капчу, при правильном ответе создается запись в БД со статусом is_approved=0.</done>
</task>

<task type="auto">
  <name>Задание 2: Уведомление и действия администратора (AUTH-02)</name>
  <files>
    - bot/handlers/onboarding.py
    - bot/handlers/admin.py
    - bot/handlers/__init__.py
  </files>
  <action>
    1. Обновить `bot/handlers/onboarding.py`: после прохождения капчи отправлять сообщение `settings.admin_id` с данными пользователя (ID, username, имя).
    2. Создать `bot/handlers/admin.py` для обработки `InlineKeyboardMarkup` с кнопками "✅ Одобрить" и "❌ Отклонить".
    3. Реализовать Callback хендлеры:
       - Одобрение: Обновить `users.is_approved = 1`, `approvals.status = 'approved'`, уведомить пользователя.
       - Отклонение: Обновить `approvals.status = 'rejected'`, уведомить пользователя об отказе.
    4. Зарегистрировать роутер в `bot/handlers/__init__.py`.
  </action>
  <verify>
    <automated>Проверить логику callback-запросов</automated>
    <manual>Как администратор, получить сообщение о новом пользователе, нажать "Одобрить", проверить изменение is_approved в БД.</manual>
    <sampling_rate>после выполнения задания</sampling_rate>
  </verify>
  <done>Администратор может одобрять/отклонять пользователей через интерфейс бота.</done>
</task>

<task type="auto">
  <name>Задание 3: Middleware для контроля доступа и верификация (AUTH-03)</name>
  <files>
    - bot/middlewares/access_middleware.py
    - main.py
    - scripts/verify_phase2.py
  </files>
  <action>
    1. Создать `bot/middlewares/access_middleware.py`. Реализовать `AccessControlMiddleware(BaseMiddleware)`:
       - Пропускать без проверки: команды `/start`, хендлеры капчи, любые сообщения от `settings.admin_id`.
       - Для остальных: проверять `is_approved` в данных пользователя (из `data['user']` или запросом к БД).
       - Если не одобрен: прерывать обработку и отправлять сообщение "Доступ ограничен. Ожидайте одобрения администратором."
    2. Подключить `AccessControlMiddleware` в `main.py` ПОСЛЕ `DbMiddleware`.
    3. Создать `scripts/verify_phase2.py`, который проверяет:
       - Наличие всех необходимых таблиц.
       - Наличие зарегистрированных роутеров (импортом dp).
       - Корректность схем БД.
  </action>
  <verify>
    <automated>python3 scripts/verify_phase2.py</automated>
    <manual>Попробовать отправить любую команду неодобренным пользователем (не /start), убедиться в получении сообщения о блокировке.</manual>
    <sampling_rate>после завершения плана</sampling_rate>
  </verify>
  <done>Система контроля доступа работает, неодобренные пользователи ограничены в действиях.</done>
</task>

</tasks>

<verification>
1. Запустить бота: `python3 main.py`.
2. Зайти новым аккаунтом (не ADMIN_ID).
3. Проверить цепочку: /start -> Капча -> Ожидание.
4. С аккаунта админа одобрить пользователя.
5. Убедиться, что доступ открыт.
6. Запустить `python3 scripts/verify_phase2.py`.
</verification>

<success_criteria>
- Капча генерируется корректно и проверяется.
- Администратор получает интерактивные уведомления.
- Middleware надежно блокирует доступ неодобренным лицам.
- Весь интерфейс бота на русском языке.
- Скрипт верификации Phase 2 проходит успешно.
</success_criteria>

<output>
После завершения создать `.planning/phases/02-bot-core-access-control/02-01-SUMMARY.md`
</output>
